<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>pgBackRest User Guide - Debian & Ubuntu / PostgreSQL 9.4</title><link rel="stylesheet" href="default.css" type="text/css"></link><meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta><meta property="og:site_name" content="pgBackRest - Reliable PostgreSQL Backup & Restore"></meta><meta property="og:title" content="pgBackRest User Guide - Debian & Ubuntu / PostgreSQL 9.4"></meta><meta property="og:type" content="website"></meta><link rel="icon" href="favicon.png" type="image/png"></link><meta property="og:image:type" content="image/png"></meta><meta property="og:image" content="http://www.pgbackrest.org/logo.png"></meta><meta name="description" content="The pgBackRest User Guide demonstrates how to quickly and easily setup pgBackRest for your PostgreSQL database. Step-by-step instructions lead the user through all the important features of the fastest, most reliable PostgreSQL backup and restore solution."></meta><meta property="og:description" content="The pgBackRest User Guide demonstrates how to quickly and easily setup pgBackRest for your PostgreSQL database. Step-by-step instructions lead the user through all the important features of the fastest, most reliable PostgreSQL backup and restore solution."></meta><body><div class="page-header"><div class="page-header-title">pgBackRest User Guide</div><div class="page-header-subtitle">Debian & Ubuntu / PostgreSQL 9.4</div></div><div class="page-menu"><div class="menu-body"><div class="menu"><a class="menu-link" href="index.html">Home</a></div><div class="menu"><a class="menu-link" href="configuration.html">Configuration</a></div><div class="menu"><a class="menu-link" href="command.html">Commands</a></div></div></div><div class="page-toc"><div class="page-toc-title">Table of Contents</div><div class="page-toc-body"><div class="section1-toc"><div class="section1-toc-title"><a href="#introduction">Introduction</a></div></div><div class="section1-toc"><div class="section1-toc-title"><a href="#concept">Concepts</a></div><div class="section2-toc"><div class="section2-toc-title"><a href="#concept/backup">Backup</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#concept/restore">Restore</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#concept/wal">Write Ahead Log (WAL)</a></div></div></div><div class="section1-toc"><div class="section1-toc-title"><a href="#installation">Installation</a></div></div><div class="section1-toc"><div class="section1-toc-title"><a href="#quickstart">Quick Start</a></div><div class="section2-toc"><div class="section2-toc-title"><a href="#quickstart/setup-demo-cluster">Setup Demo Cluster</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#quickstart/configure-stanza">Configure Cluster Stanza</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#quickstart/create-repository">Create the Repository</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#quickstart/configure-archiving">Configure Archiving</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#quickstart/check-configuration">Check the Configuration</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#quickstart/perform-backup">Perform a Backup</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#quickstart/schedule-backup">Schedule a Backup</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#quickstart/backup-info">Backup Information</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#quickstart/perform-restore">Restore a Backup</a></div></div></div><div class="section1-toc"><div class="section1-toc-title"><a href="#backup">Backup</a></div><div class="section2-toc"><div class="section2-toc-title"><a href="#backup/option-start-fast">Fast Start Option</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#backup/option-stop-auto">Automatic Stop Option</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#backup/option-archive-timeout">Archive Timeout</a></div></div></div><div class="section1-toc"><div class="section1-toc-title"><a href="#retention">Retention</a></div><div class="section2-toc"><div class="section2-toc-title"><a href="#retention/full">Full Backup Retention</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#retention/diff">Differential Backup Retention</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#retention/archive">Archive Retention</a></div></div></div><div class="section1-toc"><div class="section1-toc-title"><a href="#restore">Restore</a></div><div class="section2-toc"><div class="section2-toc-title"><a href="#restore/option-delta">Delta Option</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#restore/option-db-include">Restore Selected Databases</a></div></div></div><div class="section1-toc"><div class="section1-toc-title"><a href="#pitr">Point-in-Time Recovery</a></div></div><div class="section1-toc"><div class="section1-toc-title"><a href="#backup-host">Dedicated Backup Host</a></div><div class="section2-toc"><div class="section2-toc-title"><a href="#backup-host/install-config">Installation and Configuration</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#backup-host/perform-backup">Perform a Backup</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#backup-host/perform-restore">Restore a Backup</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#backup-host/async-archiving">Asynchronous Archiving</a></div></div></div><div class="section1-toc"><div class="section1-toc-title"><a href="#start-stop">Starting and Stopping</a></div></div><div class="section1-toc"><div class="section1-toc-title"><a href="#replication">Replication</a></div><div class="section2-toc"><div class="section2-toc-title"><a href="#replication/hot-standby">Hot Standby</a></div></div><div class="section2-toc"><div class="section2-toc-title"><a href="#replication/streaming">Streaming Replication</a></div></div></div><div class="section1-toc"><div class="section1-toc-title"><a href="#standby-backup">Backup from a Standby</a></div></div></div></div><div class="page-body"><div class="section1"><a id="introduction"></a><div class="section1-title">Introduction</div><div class="section-body"><div class="section-body-text">This user guide is intended to be followed sequentially from beginning to end &mdash; each section depends on the last. For example, the <a href="#backup">Backup</a> section relies on setup that is performed in the <a href="#quickstart">Quick Start</a> section. Once <span class="backrest">pgBackRest</span> is up and running then skipping around is possible but following the user guide in order is recommended the first time through.</div><div class="section-body-text">Although the examples are targeted at Debian/Ubuntu and <span class="postgres">PostgreSQL</span> 9.4, it should be fairly easy to apply this guide to any Unix distribution and <span class="postgres">PostgreSQL</span> version. Note that only 64-bit distributions are currently supported due to 64-bit operations in the Perl code. The only OS-specific commands are those to create, start, stop, and drop <span class="postgres">PostgreSQL</span> clusters. The <span class="backrest">pgBackRest</span> commands will be the same on any Unix system though the locations to install Perl libraries and executables may vary.<br/>
<br/>
Configuration information and documentation for PostgreSQL can be found in the <span class="postgres">PostgreSQL</span> <a href="http://www.postgresql.org/docs/9.4/static/index.html">Manual</a>.</div><div class="section-body-text">A somewhat novel approach is taken to documentation in this user guide. Each command is run on a virtual machine when the documentation is built from the XML source. This means you can have a high confidence that the commands work correctly in the order presented. Output is captured and displayed below the command when appropriate. If the output is not included it is because it was deemed not relevant or was considered a distraction from the narrative.</div><div class="section-body-text">All commands are intended to be run as an unprivileged user that has sudo privileges for both the <span class="user">root</span> and <span class="user">postgres</span> users. It's also possible to run the commands directly as their respective users without modification and in that case the <span class="cmd">sudo</span> commands can be stripped off.</div></div></div><div class="section1"><a id="concept"></a><div class="section1-title">Concepts</div><div class="section-body"><div class="section-body-text">The following concepts are defined as they are relevant to <span class="backrest">pgBackRest</span>, <span class="postgres">PostgreSQL</span>, and this user guide.</div><div class="section2"><a id="concept/backup"></a><div class="section2-title">Backup</div><div class="section-body"><div class="section-body-text">A backup is a consistent copy of a database cluster that can be restored to recover from a hardware failure, to perform Point-In-Time Recovery, or to bring up a new standby.</div><div class="section-body-text"><b>Full Backup</b>: <span class="backrest">pgBackRest</span> copies the entire contents of the database cluster to the backup server. The first backup of the database cluster is always a Full Backup. <span class="backrest">pgBackRest</span> is always able to restore a full backup directly. The full backup does not depend on any files outside of the full backup for consistency.</div><div class="section-body-text"><b>Differential Backup</b>: <span class="backrest">pgBackRest</span> copies only those database cluster files that have changed since the last full backup. <span class="backrest">pgBackRest</span> restores a differential backup by copying all of the files in the chosen differential backup and the appropriate unchanged files from the previous full backup. The advantage of a differential backup is that it requires less disk space than a full backup, however, the differential backup and the full backup must both be valid to restore the differential backup.</div><div class="section-body-text"><b>Incremental Backup</b>: <span class="backrest">pgBackRest</span> copies only those database cluster files that have changed since the last backup (which can be another incremental backup, a differential backup, or a full backup). As an incremental backup only includes those files changed since the prior backup, they are generally much smaller than full or differential backups. As with the differential backup, the incremental backup depends on other backups to be valid to restore the incremental backup. Since the incremental backup includes only those files since the last backup, all prior incremental backups back to the prior differential, the prior differential backup, and the prior full backup must all be valid to perform a restore of the incremental backup. If no differential backup exists then all prior incremental backups back to the prior full backup, which must exist, and the full backup itself must be valid to restore the incremental backup.</div></div></div><div class="section2"><a id="concept/restore"></a><div class="section2-title">Restore</div><div class="section-body"><div class="section-body-text">A restore is the act of copying a backup to a system where it will be started as a live database cluster. A restore requires the backup files and one or more WAL segments in order to work correctly.</div></div></div><div class="section2"><a id="concept/wal"></a><div class="section2-title">Write Ahead Log (WAL)</div><div class="section-body"><div class="section-body-text">WAL is the mechanism that <span class="postgres">PostgreSQL</span> uses to ensure that no committed changes are lost. Transactions are written sequentially to the WAL and a transaction is considered to be committed when those writes are flushed to disk. Afterwards, a background process writes the changes into the main database cluster files (also known as the heap). In the event of a crash, the WAL is replayed to make the database consistent.</div><div class="section-body-text">WAL is conceptually infinite but in practice is broken up into individual 16MB files called segments. WAL segments follow the naming convention <span class="id">0000000100000A1E000000FE</span> where the first 8 hexadecimal digits represent the timeline and the next 16 digits are the logical sequence number (LSN).</div></div></div></div></div><div class="section1"><a id="installation"></a><div class="section1-title">Installation</div><div class="section-body"><div class="section-body-text"><span class="backrest">pgBackRest</span> is written in Perl which is included with Debian/Ubuntu by default. The <span class="id">DBD::Pg</span> module must also be installed.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Install the <span class="id">DBD::Pg</span> module</div><div class="execute-body"><pre class="execute-body-cmd">sudo apt-get install libdbd-pg-perl</pre></div></div><div class="section-body-text">Debian/Ubuntu packages for <span class="backrest">pgBackRest</span> are available, but if they are not provided on your distribution/version it is easy to download the source and install manually.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Download version <span class="id">1.09</span> of <span class="backrest">pgBackRest</span></div><div class="execute-body"><pre class="execute-body-cmd">wget -q -O - \
       https://github.com/pgbackrest/pgbackrest/archive/release/1.09.tar.gz | \
       tar zx -C ~</pre></div></div><div class="section-body-text">If <span class="backrest">pgBackRest</span> has been installed before it's best to be sure that no prior copies of it are still installed. Depending on how old the version of pgBackRest is it may have been installed in a few different locations. The following commands will remove all prior versions of pgBackRest.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Remove prior <span class="backrest">pgBackRest</span> installations</div><div class="execute-body"><pre class="execute-body-cmd">sudo rm -f /usr/bin/pgbackrest</pre><pre class="execute-body-cmd">sudo rm -f /usr/bin/pg_backrest</pre><pre class="execute-body-cmd">sudo rm -rf /usr/lib/perl5/BackRest</pre><pre class="execute-body-cmd">sudo rm -rf /usr/share/perl5/BackRest</pre><pre class="execute-body-cmd">sudo rm -rf /usr/lib/perl5/pgBackRest</pre><pre class="execute-body-cmd">sudo rm -rf /usr/share/perl5/pgBackRest</pre></div></div><div class="section-body-text">The new version can now be installed.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Install <span class="backrest">pgBackRest</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo cp -r ~/pgbackrest-release-1.09/lib/pgBackRest \
       /usr/share/perl5</pre><pre class="execute-body-cmd">sudo find /usr/share/perl5/pgBackRest -type f -exec chmod 644 {} +</pre><pre class="execute-body-cmd">sudo find /usr/share/perl5/pgBackRest -type d -exec chmod 755 {} +</pre><pre class="execute-body-cmd">sudo cp ~/pgbackrest-release-1.09/bin/pgbackrest /usr/bin/pgbackrest</pre><pre class="execute-body-cmd">sudo chmod 755 /usr/bin/pgbackrest</pre><pre class="execute-body-cmd">sudo mkdir -m 770 /var/log/pgbackrest</pre><pre class="execute-body-cmd">sudo chown postgres:postgres /var/log/pgbackrest</pre></div></div><div class="section-body-text"><span class="backrest">pgBackRest</span> should now be properly installed but it is best to check. If any dependencies were missed then you will get an error when running <span class="backrest">pgBackRest</span> from the command line.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Make sure the installation worked</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest</pre><pre class="execute-body-output">pgBackRest 1.09 - General help

Usage:
    pgbackrest [options] [command]

Commands:
    archive-get   Get a WAL segment from the archive.
    archive-push  Push a WAL segment to the archive.
    backup        Backup a database cluster.
    check         Check the configuration.
    expire        Expire backups that exceed retention.
    help          Get help.
    info          Retrieve information about backups.
    restore       Restore a database cluster.
    start         Allow pgBackRest processes to run.
    stop          Stop pgBackRest processes from running.
    version       Get version.

Use 'pgbackrest help [command]' for more information.</pre></div></div></div></div><div class="section1"><a id="quickstart"></a><div class="section1-title">Quick Start</div><div class="section-body"><div class="section-body-text">The Quick Start section will cover basic configuration of <span class="backrest">pgBackRest</span> and <span class="postgres">PostgreSQL</span> and introduce the <span class="cmd">backup</span>, <span class="cmd">restore</span>, and <span class="cmd">info</span> commands.</div><div class="section2"><a id="quickstart/setup-demo-cluster"></a><div class="section2-title">Setup Demo Cluster</div><div class="section-body"><div class="section-body-text">Creating the demo cluster is optional but is strongly recommended, especially for new users, since the example commands in the user guide reference the demo cluster; the examples assume the demo cluster is running on the default port (i.e. 5432). The cluster will not be started until a later section because there is still some configuration to do.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Create the demo cluster</div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_createcluster 9.4 demo</pre><pre class="execute-body-output">Creating new cluster 9.4/demo ...
  config /etc/postgresql/9.4/demo
  data   /var/lib/postgresql/9.4/demo
  locale C
  socket /var/run/postgresql
  port   5432</pre></div></div><div class="section-body-text">By default <span class="postgres">PostgreSQL</span> will only accept local connections. The examples in this guide will require connections from other servers so <span class="pg-option">listen_addresses</span> is configured to listen on all interfaces. This may not be appropriate for secure installations.</div><div class="config"><div class="config-title"><span class="host">db-master</span>:<span class="file">/etc/postgresql/9.4/demo/postgresql.conf</span> <b>&#x21d2;</b> Set <span class="pg-option">listen_addresses</span></div><div class="config-body"><div class="config-body-output">listen_addresses = '*'</div></div></div><div class="section-body-text">For demonstration purposes the <span class="pg-option">log_line_prefix</span> setting will be minimally configured. This keeps the log output as brief as possible to better illustrate important information.</div><div class="config"><div class="config-title"><span class="host">db-master</span>:<span class="file">/etc/postgresql/9.4/demo/postgresql.conf</span> <b>&#x21d2;</b> Set <span class="pg-option">log_line_prefix</span></div><div class="config-body"><div class="config-body-output">listen_addresses = '*'<br/>
log_line_prefix = ''</div></div></div></div></div><div class="section2"><a id="quickstart/configure-stanza"></a><div class="section2-title">Configure Cluster Stanza</div><div class="section-body"><div class="section-body-text">A stanza is the configuration for a <span class="postgres">PostgreSQL</span> database cluster that defines where it is located, how it will be backed up, archiving options, etc. Most db servers will only have one Postgres database cluster and therefore one stanza, whereas backup servers will have a stanza for every database cluster that needs to be backed up.<br/>
<br/>
It is tempting to name the stanza after the primary cluster but a better name describes the databases contained in the cluster. Because the stanza name will be used for the primary and all replicas it is more appropriate to choose a name that describes the actual function of the cluster, such as app or dw, rather than the local cluster name, such as main or prod.</div><div class="section-body-text">The name 'demo' describes the purpose of this cluster accurately so that will also make a good stanza name.</div><div class="section-body-text"><span class="backrest">pgBackRest</span> needs to know where the base data directory for the <span class="postgres">PostgreSQL</span> cluster is located. The path can be requested from <span class="postgres">PostgreSQL</span> directly but in a recovery scenario the <span class="postgres">PostgreSQL</span> process will not be available. During backups the value supplied to <span class="backrest">pgBackRest</span> will be compared against the path that <span class="postgres">PostgreSQL</span> is running on and they must be equal or the backup will return an error. Make sure that <span class="br-option">db-path</span> is exactly equal to <span class="pg-option">data_directory</span> in <span class="file">postgresql.conf</span>.</div><div class="section-body-text">By default Debian/Ubuntu stores clusters in <span class="path">/var/lib/postgresql/[version]/[cluster]</span> so it is easy to determine the correct path for the data directory.</div><div class="section-body-text">When creating the <span class="file">/etc/pgbackrest.conf</span> file, the database owner (usually <span class="id">postgres</span>) must be granted read privileges.</div><div class="config"><div class="config-title"><span class="host">db-master</span>:<span class="file">/etc/pgbackrest.conf</span> <b>&#x21d2;</b> Configure the <span class="postgres">PostgreSQL</span> cluster data directory</div><div class="config-body"><div class="config-body-output">[demo]<br/>
db-path=/var/lib/postgresql/9.4/demo</div></div></div><div class="section-body-text"><span class="backrest">pgBackRest</span> configuration files follow the Windows INI convention. Sections are denoted by text in brackets and key/value pairs are contained in each section. Lines beginning with <span class="id">#</span> are ignored and can be used as comments.</div></div></div><div class="section2"><a id="quickstart/create-repository"></a><div class="section2-title">Create the Repository</div><div class="section-body"><div class="section-body-text">The repository is where <span class="backrest">pgBackRest</span> stores backup and archives WAL segments.<br/>
<br/>
If you are new to backup then it will be difficult to estimate in advance how much space you'll need. The best thing to do is take some backups then record the size of different types of backups (full/incr/diff) and measure the amount of WAL generated per day. This will give you a general idea of how much space you'll need, though of course requirements will likely change over time as your database evolves.</div><div class="section-body-text">For this demonstration the repository will be stored on the same host as the <span class="postgres">PostgreSQL</span> server. This is the simplest configuration and is useful in cases where traditional backup software is employed to backup the database host.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Create the <span class="backrest">pgBackRest</span> repository</div><div class="execute-body"><pre class="execute-body-cmd">sudo mkdir /var/lib/pgbackrest</pre><pre class="execute-body-cmd">sudo chmod 750 /var/lib/pgbackrest</pre><pre class="execute-body-cmd">sudo chown postgres:postgres /var/lib/pgbackrest</pre></div></div><div class="section-body-text">The repository path must be configured so <span class="backrest">pgBackRest</span> knows where to find it.</div><div class="config"><div class="config-title"><span class="host">db-master</span>:<span class="file">/etc/pgbackrest.conf</span> <b>&#x21d2;</b> Configure the <span class="backrest">pgBackRest</span> repository path</div><div class="config-body"><div class="config-body-output">[demo]<br/>
db-path=/var/lib/postgresql/9.4/demo<br/>
<br/>
[global]<br/>
repo-path=/var/lib/pgbackrest</div></div></div></div></div><div class="section2"><a id="quickstart/configure-archiving"></a><div class="section2-title">Configure Archiving</div><div class="section-body"><div class="section-body-text">Backing up a running <span class="postgres">PostgreSQL</span> cluster requires WAL archiving to be enabled. Note that <i>at least</i> one WAL segment will be created during the backup process even if no explicit writes are made to the cluster.</div><div class="config"><div class="config-title"><span class="host">db-master</span>:<span class="file">/etc/postgresql/9.4/demo/postgresql.conf</span> <b>&#x21d2;</b> Configure archive settings</div><div class="config-body"><div class="config-body-output">archive_command = 'pgbackrest --stanza=demo archive-push %p'<br/>
archive_mode = on<br/>
listen_addresses = '*'<br/>
log_line_prefix = ''<br/>
max_wal_senders = 3<br/>
wal_level = hot_standby</div></div></div><div class="section-body-text">The <span class="pg-option">wal_level</span> setting must be set to <span class="pg-setting">archive</span> at a minimum but <span class="pg-setting">hot_standby</span> and <span class="pg-setting">logical</span> also work fine for backups. Setting <span class="pg-option">wal_level</span> to <span class="pg-setting">hot_standy</span> and increasing <span class="pg-option">max_wal_senders</span> is a good idea even if you do not currently run a hot standby as this will allow them to be added later without restarting the master cluster.</div><div class="section-body-text">The <span class="postgres">PostgreSQL</span> cluster must be restarted after making these changes and before performing a backup.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Restart the demo cluster</div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo restart</pre></div></div><div class="section-body-text">When archiving a WAL segment is expected to take more than 60 seconds (the default) then the <span class="br-option">archive-timeout</span> option should be increased.</div></div></div><div class="section2"><a id="quickstart/check-configuration"></a><div class="section2-title">Check the Configuration</div><div class="section-body"><div class="section-body-text">The <span class="cmd">check</span> command validates that <span class="backrest">pgBackRest</span> and the <span class="pg-setting">archive_command</span> setting are configured correctly for archiving and backups. It detects misconfigurations, particularly in archiving, that result in incomplete backups because required WAL segments did not reach the archive. The command can be run on the database or the backup host.<br/>
<br/>
Note that <span class="id">pg_create_restore_point('pgBackRest Archive Check')</span> and <span class="id">pg_switch_xlog()</span> are called to force <span class="postgres">PostgreSQL</span> to archive a WAL segment. Restore points are only supported in <span class="postgres">PostgreSQL</span> >= 9.1 so for older versions the <span class="cmd">check</span> command may fail if there has been no write activity since the last log rotation.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Check the configuration</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --log-level-console=info check</pre><pre class="execute-body-output">P00   INFO: check start 1.09: --db-path=/var/lib/postgresql/9.4/demo --log-level-console=info --log-level-stderr=off --repo-path=/var/lib/pgbackrest --stanza=demo
P00   INFO: switch xlog 000000010000000000000001</pre><pre class="execute-body-output-highlight">P00   INFO: WAL segment 000000010000000000000001 successfully stored in the archive at '/var/lib/pgbackrest/archive/demo/9.4-1/0000000100000000/000000010000000000000001-0c3ecb0600ef7f803a1ab99756a2931e99b37e12.gz'</pre><pre class="execute-body-output">P00   INFO: check stop</pre></div></div></div></div><div class="section2"><a id="quickstart/perform-backup"></a><div class="section2-title">Perform a Backup</div><div class="section-body"><div class="section-body-text">To perform a backup of the <span class="postgres">PostgreSQL</span> cluster run <span class="backrest">pgBackRest</span> with the <span class="cmd">backup</span> command.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Backup the demo cluster</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo \
       --log-level-console=info backup</pre><pre class="execute-body-output">P00   WARN: option retention-full is not set, the repository may run out of space
       HINT: to retain full backups indefinitely (without warning), set option 'retention-full' to the maximum.
P00   INFO: backup start 1.09: --db-path=/var/lib/postgresql/9.4/demo --log-level-console=info --log-level-stderr=off --repo-path=/var/lib/pgbackrest --stanza=demo</pre><pre class="execute-body-output-highlight">P00   WARN: no prior backup exists, incr backup has been changed to full</pre><pre class="execute-body-output">P00   INFO: execute exclusive pg_start_backup() with label "pgBackRest backup started at 2016-10-10 21:07:29": backup begins after the next regular checkpoint completes
P00   INFO: backup start archive = 000000010000000000000002, lsn = 0/2000028
       [filtered 759 lines of output]
P01   INFO: backup file /var/lib/postgresql/9.4/demo/base/1/11885 (0B, 99%)
P00   INFO: backup file /var/lib/postgresql/9.4/demo/global/pg_control (8KB, 100%) checksum d7cf38ee1cd9f64d10f8cde0dd667a55c85c0712</pre><pre class="execute-body-output-highlight">P00   INFO: full backup size = 19.3MB</pre><pre class="execute-body-output">P00   INFO: execute exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 000000010000000000000002, lsn = 0/20000F0
       [filtered 4 lines of output]</pre></div></div><div class="section-body-text">By default <span class="backrest">pgBackRest</span> will attempt to perform an incremental backup. However, an incremental backup must be based on a full backup and since no full backup existed <span class="backrest">pgBackRest</span> ran a full backup instead.</div><div class="section-body-text">The <span class="br-option">type</span> option can be used to specify a full or differential backup.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Differential backup of the demo cluster</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=diff \
       --log-level-console=info backup</pre><pre class="execute-body-output">       [filtered 8 lines of output]
P01   INFO: backup file /var/lib/postgresql/9.4/demo/backup_label (236B, 2%) checksum fb5fb7eb6874731c5ed01f89f362c7a8820df298
P00   INFO: backup file /var/lib/postgresql/9.4/demo/global/pg_control (8KB, 100%) checksum c5d6dcb8d4e0caff65a5a823120509fa37a41eb2</pre><pre class="execute-body-output-highlight">P00   INFO: diff backup size = 8.2KB</pre><pre class="execute-body-output">P00   INFO: execute exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 000000010000000000000003, lsn = 0/30000F0
       [filtered 4 lines of output]</pre></div></div><div class="section-body-text">This time there was no warning because a full backup already existed. While incremental backups can be based on a full <i>or</i> differential backup, differential backups must be based on a full backup. A full backup can be performed by running the <span class="cmd">backup</span> command with <span class="br-setting">--type=full</span>.</div><div class="section-body-text">More information about the <span class="cmd">backup</span> command can be found in the <a href="#backup">Backup</a> section.</div></div></div><div class="section2"><a id="quickstart/schedule-backup"></a><div class="section2-title">Schedule a Backup</div><div class="section-body"><div class="section-body-text">Backups can be scheduled with utilities such as cron.</div><div class="section-body-text">In the following example, two cron jobs are configured to run; full backups are scheduled for 6:30 AM every Sunday with differential backups scheduled for 6:30 AM Monday through Saturday. If this crontab is installed for the first time mid-week, then pgBackRest will run a full backup the first time the differential job is executed, followed the next day by a differential backup.</div><pre class="code-block">#m h   dom mon dow   command
30 06  *   *   0     pgbackrest --type=full --stanza=demo backup
30 06  *   *   1-6   pgbackrest --type=diff --stanza=demo backup</pre><div class="section-body-text">Once backups are scheduled it's important to configure retention so backups are expired on a regular schedule, see <a href="#retention">Retention</a>.</div></div></div><div class="section2"><a id="quickstart/backup-info"></a><div class="section2-title">Backup Information</div><div class="section-body"><div class="section-body-text">Use the <span class="cmd">info</span> command to get information about backups.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Get info for the demo cluster</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest info</pre><pre class="execute-body-output">stanza: demo
    status: ok
</pre><pre class="execute-body-output-highlight">    full backup: 20161010-210736F</pre><pre class="execute-body-output">        start / stop timestamp: 2016-10-10 21:07:29 / 2016-10-10 21:07:36
        database size: 19.3MB, backup size: 19.3MB
        repository size: 2.2MB, repository backup size: 2.2MB
</pre><pre class="execute-body-output-highlight">    diff backup: 20161010-210736F_20161010-210740D</pre><pre class="execute-body-output">        start / stop timestamp: 2016-10-10 21:07:37 / 2016-10-10 21:07:40
        database size: 19.3MB, backup size: 8.2KB
        repository size: 2.2MB, repository backup size: 339B
        backup reference list: 20161010-210736F</pre></div></div><div class="section-body-text">The backups are displayed oldest to newest. The oldest backup will <i>always</i> be a full backup (indicated by an <span class="id">F</span> at the end of the label) but the newest backup can be full, differential (ends with <span class="id">D</span>), or incremental (ends with <span class="id">I</span>).</div><div class="section-body-text">The '<span class="id">start / stop timestamp</span>' defines the time period when the backup ran. The '<span class="id">stop timestamp</span>' can be used to determine the backup to use when performing Point-In-Time Recovery. More information about Point-In-Time Recovery can be found in the <a href="#pitr">Point-In-Time Recovery</a> section.</div><div class="section-body-text">The '<span class="id">database size</span>' is the full uncompressed size of the database while '<span class="id">backup size</span>' is the amount of data actually backed up (these will be the same for full backups). The '<span class="id">repository size</span>' includes all the files from this backup and any referenced backups that are required to restore the database while '<span class="id">repository backup size</span>' includes only the files in this backup (these will also be the same for full backups). Repository sizes reflect compressed file sizes if compression is enabled in <span class="backrest">pgBackRest</span> or the filesystem.</div><div class="section-body-text">The '<span class="id">backup reference list</span>' contains the additional backups that are required to restore this backup.</div></div></div><div class="section2"><a id="quickstart/perform-restore"></a><div class="section2-title">Restore a Backup</div><div class="section-body"><div class="section-body-text">Backups can protect you from a number of disaster scenarios, the most common of which are hardware failure and data corruption. The easiest way to simulate data corruption is to remove an important <span class="postgres">PostgreSQL</span> cluster file.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Stop the demo cluster and delete the <span class="file">pg_control</span> file</div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo stop</pre><pre class="execute-body-cmd">sudo -u postgres rm /var/lib/postgresql/9.4/demo/global/pg_control</pre></div></div><div class="section-body-text">Starting the cluster without this important file will result in an error.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Attempt to start the corrupted demo cluster</div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo start</pre><pre class="execute-body-output">The PostgreSQL server failed to start. Please check the log output:</pre><pre class="execute-body-output-highlight-error">postgres: could not find the database system</pre><pre class="execute-body-output">Expected to find it in the directory "/var/lib/postgresql/9.4/demo",
but could not open file "/var/lib/postgresql/9.4/demo/global/pg_control": No such file or directory</pre></div></div><div class="section-body-text">To restore a backup of the <span class="postgres">PostgreSQL</span> cluster run <span class="backrest">pgBackRest</span> with the <span class="cmd">restore</span> command. The cluster needs to be stopped (in this case it is already stopped) and all files must be removed from the <span class="postgres">PostgreSQL</span> data directory.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Remove old files from demo cluster</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres find /var/lib/postgresql/9.4/demo -mindepth 1 -delete</pre></div></div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Restore the demo cluster and start <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo restore</pre><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo start</pre></div></div><div class="section-body-text">This time the cluster started successfully since the restore replaced the missing <span class="file">pg_control</span> file.</div><div class="section-body-text">More information about the <span class="cmd">restore</span> command can be found in the <a href="#restore">Restore</a> section.</div></div></div></div></div><div class="section1"><a id="backup"></a><div class="section1-title">Backup</div><div class="section-body"><div class="section-body-text">The Backup section introduces additional <span class="cmd">backup</span> command features.</div><div class="section2"><a id="backup/option-start-fast"></a><div class="section2-title">Fast Start Option</div><div class="section-body"><div class="section-body-text">By default <span class="backrest">pgBackRest</span> will wait for the next regularly scheduled checkpoint before starting a backup. Depending on the <span class="pg-option">checkpoint_timeout</span> and <span class="pg-option">checkpoint_segments</span> settings in <span class="postgres">PostgreSQL</span> it may be quite some time before a checkpoint completes and the backup can begin.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Incremental backup of the demo cluster with the regularly scheduled checkpoint</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=incr \
       --log-level-console=info backup</pre><pre class="execute-body-output">       [filtered 2 lines of output]
P00   INFO: backup start 1.09: --db-path=/var/lib/postgresql/9.4/demo --log-level-console=info --log-level-stderr=off --repo-path=/var/lib/pgbackrest --stanza=demo --type=incr
P00   INFO: last backup label = 20161010-210736F_20161010-210740D, version = 1.09</pre><pre class="execute-body-output-highlight">P00   INFO: execute exclusive pg_start_backup() with label "pgBackRest backup started at 2016-10-10 21:07:52": backup begins after the next regular checkpoint completes</pre><pre class="execute-body-output">P00   INFO: backup start archive = 000000020000000000000006, lsn = 0/6000028
P01   INFO: local process 1 start for host db-1
       [filtered 15 lines of output]</pre></div></div><div class="section-body-text">When <span class="br-setting">--start-fast</span> is passed on the command-line or <span class="br-setting">start-fast=y</span> is set in <span class="file">/etc/pgbackrest.conf</span> an immediate checkpoint is requested and the backup will start more quickly. This is convenient for testing and for ad-hoc backups. For instance, if a backup is being taken at the beginning of a release window it makes no sense to wait for a checkpoint. Since regularly scheduled backups generally only happen once per day it is unlikely that enabling the <span class="br-option">start-fast</span> in <span class="file">/etc/pgbackrest.conf</span> will negatively affect performance, however for high-volume transactional systems you may want to pass <span class="br-setting">--start-fast</span> on the command-line instead. Alternately, it is possible to override the setting in the configuration file by passing <span class="br-setting">--no-start-fast</span> on the command-line.</div><div class="config"><div class="config-title"><span class="host">db-master</span>:<span class="file">/etc/pgbackrest.conf</span> <b>&#x21d2;</b> Enable the <span class="br-option">start-fast</span> option</div><div class="config-body"><div class="config-body-output">[demo]<br/>
db-path=/var/lib/postgresql/9.4/demo<br/>
<br/>
[global]<br/>
repo-path=/var/lib/pgbackrest<br/>
start-fast=y</div></div></div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Incremental backup of the demo cluster with an immediate checkpoint</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=incr \
       --log-level-console=info backup</pre><pre class="execute-body-output">       [filtered 2 lines of output]
P00   INFO: backup start 1.09: --db-path=/var/lib/postgresql/9.4/demo --log-level-console=info --log-level-stderr=off --repo-path=/var/lib/pgbackrest --stanza=demo --start-fast --type=incr
P00   INFO: last backup label = 20161010-210736F_20161010-210756I, version = 1.09</pre><pre class="execute-body-output-highlight">P00   INFO: execute exclusive pg_start_backup() with label "pgBackRest backup started at 2016-10-10 21:07:57": backup begins after the requested immediate checkpoint completes</pre><pre class="execute-body-output">P00   INFO: backup start archive = 000000020000000000000007, lsn = 0/7000028
P01   INFO: local process 1 start for host db-1
       [filtered 10 lines of output]</pre></div></div></div></div><div class="section2"><a id="backup/option-stop-auto"></a><div class="section2-title">Automatic Stop Option</div><div class="section-body"><div class="section-body-text">Sometimes <span class="backrest">pgBackRest</span> will exit unexpectedly and the backup in progress on the <span class="postgres">PostgreSQL</span> cluster will not be properly stopped. <span class="backrest">pgBackRest</span> exits as quickly as possible when an error occurs so that the cause can be reported accurately and is not masked by another problem that might happen during a more extensive cleanup.</div><div class="section-body-text">Here an error is intentionally caused by removing repository permissions.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Revoke write privileges in the <span class="backrest">pgBackRest</span> repository and attempt a backup</div><div class="execute-body"><pre class="execute-body-cmd">sudo chmod 550 /var/lib/pgbackrest/temp</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=incr \
       --log-level-console=info backup</pre><pre class="execute-body-output">       [filtered 4 lines of output]
P00   INFO: execute exclusive pg_start_backup() with label "pgBackRest backup started at 2016-10-10 21:08:01": backup begins after the requested immediate checkpoint completes
P00   INFO: backup start archive = 000000020000000000000008, lsn = 0/8000028</pre><pre class="execute-body-output-highlight-error">P00  ERROR: [122]: unable to create /var/lib/pgbackrest/temp/demo.tmp: Permission denied</pre><pre class="execute-body-output">P00   INFO: backup stop</pre></div></div><div class="section-body-text">Even when the permissions are fixed <span class="backrest">pgBackRest</span> will still be unable to perform a backup because the <span class="postgres">PostgreSQL</span> cluster is stuck in backup mode.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Restore write privileges in the <span class="backrest">pgBackRest</span> repository and attempt a backup</div><div class="execute-body"><pre class="execute-body-cmd">sudo chmod 750 /var/lib/pgbackrest/temp</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=incr \
       --log-level-console=info backup</pre><pre class="execute-body-output">       [filtered 3 lines of output]
P00   INFO: last backup label = 20161010-210736F_20161010-210800I, version = 1.09
P00   INFO: execute exclusive pg_start_backup() with label "pgBackRest backup started at 2016-10-10 21:08:03": backup begins after the requested immediate checkpoint completes</pre><pre class="execute-body-output-highlight-error">P00  ERROR: [132]: ERROR:  a backup is already in progress</pre><pre class="execute-body-output">              HINT:  Run pg_stop_backup() and try again.:
              select to_char(current_timestamp, 'YYYY-MM-DD HH24:MI:SS.US TZ'), pg_xlogfile_name(lsn), lsn::text from pg_start_backup('pgBackRest backup started at 2016-10-10 21:08:03', true) as lsn</pre></div></div><div class="section-body-text">Enabling the <span class="br-option">stop-auto</span> option allows <span class="backrest">pgBackRest</span> to stop the current backup if it detects that no other <span class="backrest">pgBackRest</span> backup process is running.</div><div class="config"><div class="config-title"><span class="host">db-master</span>:<span class="file">/etc/pgbackrest.conf</span> <b>&#x21d2;</b> Enable the <span class="br-option">stop-auto</span> option</div><div class="config-body"><div class="config-body-output">[demo]<br/>
db-path=/var/lib/postgresql/9.4/demo<br/>
<br/>
[global]<br/>
repo-path=/var/lib/pgbackrest<br/>
start-fast=y<br/>
stop-auto=y</div></div></div><div class="section-body-text">Now <span class="backrest">pgBackRest</span> will stop the old backup and start a new one so the process completes successfully.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Perform an incremental backup</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=incr \
       --log-level-console=info backup</pre><pre class="execute-body-output">       [filtered 2 lines of output]
P00   INFO: backup start 1.09: --db-path=/var/lib/postgresql/9.4/demo --log-level-console=info --log-level-stderr=off --repo-path=/var/lib/pgbackrest --stanza=demo --start-fast --stop-auto --type=incr
P00   INFO: last backup label = 20161010-210736F_20161010-210800I, version = 1.09</pre><pre class="execute-body-output-highlight">P00   WARN: the cluster is already in backup mode but no pgBackRest backup process is running. pg_stop_backup() will be called so a new backup can be started.</pre><pre class="execute-body-output">P00   INFO: execute exclusive pg_stop_backup() and wait for all WAL segments to archive</pre><pre class="execute-body-output-highlight">P00   INFO: execute exclusive pg_start_backup() with label "pgBackRest backup started at 2016-10-10 21:08:05": backup begins after the requested immediate checkpoint completes</pre><pre class="execute-body-output">P00   INFO: backup start archive = 000000020000000000000009, lsn = 0/9000028
P01   INFO: local process 1 start for host db-1
       [filtered 10 lines of output]</pre></div></div><div class="section-body-text">Although useful this feature may not be appropriate when another third-party backup solution is being used to take online backups as <span class="backrest">pgBackRest</span> will not recognize that the other software is running and may terminate a backup started by that software. However, it would be unusual to run more than one third-party backup solution at the same time so this is not likely to be a problem.</div><div class="section-body-text">Note that <span class="id">pg_dump</span> and <span class="id">pg_base_backup</span> do not take online backups so are not affected. It is safe to run them in conjunction with <span class="backrest">pgBackRest</span>.</div></div></div><div class="section2"><a id="backup/option-archive-timeout"></a><div class="section2-title">Archive Timeout</div><div class="section-body"><div class="section-body-text">During an online backup, <span class="backrest">pgBackRest</span> waits for WAL segments that are required to make the backup consistent to be archived. This wait time is governed by the <span class="br-option">archive-timeout</span> option which defaults to 60 seconds. If archiving an individual segment is known to take longer, then this option should be increased.</div></div></div></div></div><div class="section1"><a id="retention"></a><div class="section1-title">Retention</div><div class="section-body"><div class="section-body-text">Generally it is best to retain as many backups as possible to provide a greater window for <a href="#pitr">Point-in-Time Recovery</a>, but practical concerns such as disk space must also be considered. Retention options remove older backups once they are no longer needed.</div><div class="section2"><a id="retention/full"></a><div class="section2-title">Full Backup Retention</div><div class="section-body"><div class="section-body-text">Set <span class="br-option">retention-full</span> to the number of full backups required. New backups must be completed before expiration will occur &mdash; that means if <span class="br-setting">retention-full=2</span> then there will be three full backups stored before the oldest one is expired.</div><div class="config"><div class="config-title"><span class="host">db-master</span>:<span class="file">/etc/pgbackrest.conf</span> <b>&#x21d2;</b> Configure <span class="br-option">retention-full</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
db-path=/var/lib/postgresql/9.4/demo<br/>
<br/>
[global]<br/>
repo-path=/var/lib/pgbackrest<br/>
retention-full=2<br/>
start-fast=y<br/>
stop-auto=y</div></div></div><div class="section-body-text">Backup <span class="br-setting">retention-full=2</span> but currently there is only one full backup so the next full backup to run will not expire any full backups.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Perform a full backup</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=full \
       --log-level-console=detail backup</pre><pre class="execute-body-output">       [filtered 768 lines of output]
P00   INFO: backup stop
P00   INFO: expire start 1.09: --log-level-console=detail --log-level-stderr=off --repo-path=/var/lib/pgbackrest --retention-archive=2 --retention-full=2 --stanza=demo</pre><pre class="execute-body-output-highlight">P00 DETAIL: archive retention on backup 20161010-210736F, start = 000000010000000000000002
P00 DETAIL: remove archive: start = 000000010000000000000001, stop = 000000010000000000000001</pre><pre class="execute-body-output">P00   INFO: expire stop</pre></div></div><div class="section-body-text">Archive <i>is</i> expired because WAL segments were generated before the oldest backup. These are not useful for recovery &mdash; only WAL segments generated after a backup can be used to recover that backup.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Perform a full backup</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=full \
       --log-level-console=info backup</pre><pre class="execute-body-output">       [filtered 768 lines of output]
P00   INFO: backup stop
P00   INFO: expire start 1.09: --log-level-console=info --log-level-stderr=off --repo-path=/var/lib/pgbackrest --retention-archive=2 --retention-full=2 --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: expire full backup set: 20161010-210736F, 20161010-210736F_20161010-210740D, 20161010-210736F_20161010-210756I, 20161010-210736F_20161010-210800I, 20161010-210736F_20161010-210809I</pre><pre class="execute-body-output">P00   INFO: remove expired backup 20161010-210736F_20161010-210809I
P00   INFO: remove expired backup 20161010-210736F_20161010-210800I
       [filtered 3 lines of output]</pre></div></div><div class="section-body-text">The <span class="id">20161010-210736F</span> full backup is expired and archive retention is based on the <span class="id">20161010-210816F</span> which is now the oldest full backup.</div></div></div><div class="section2"><a id="retention/diff"></a><div class="section2-title">Differential Backup Retention</div><div class="section-body"><div class="section-body-text">Set <span class="br-option">retention-diff</span> to the number of differential backups required. Differentials only rely on the prior full backup so it is possible to create a <q>rolling</q> set of differentials for the last day or more. This allows quick restores to recent points-in-time but reduces overall space consumption.</div><div class="config"><div class="config-title"><span class="host">db-master</span>:<span class="file">/etc/pgbackrest.conf</span> <b>&#x21d2;</b> Configure <span class="br-option">retention-diff</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
db-path=/var/lib/postgresql/9.4/demo<br/>
<br/>
[global]<br/>
repo-path=/var/lib/pgbackrest<br/>
retention-diff=1<br/>
retention-full=2<br/>
start-fast=y<br/>
stop-auto=y</div></div></div><div class="section-body-text">Backup <span class="br-setting">retention-diff=1</span> so two differentials will need to be performed before one is expired. An incremental backup is added to demonstrate incremental expiration. Incremental backups cannot be expired independently &mdash; they are always expired with their related full or differential backup.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Perform differential and incremental backups</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=diff backup</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=incr backup</pre></div></div><div class="section-body-text">Now performing a differential backup will expire the previous differential and incremental backups leaving only one differential backup.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Perform a differential backup</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=diff \
       --log-level-console=info backup</pre><pre class="execute-body-output">       [filtered 12 lines of output]
P00   INFO: backup stop
P00   INFO: expire start 1.09: --log-level-console=info --log-level-stderr=off --repo-path=/var/lib/pgbackrest --retention-archive=2 --retention-diff=1 --retention-full=2 --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: expire diff backup set: 20161010-210823F_20161010-210827D, 20161010-210823F_20161010-210831I</pre><pre class="execute-body-output">P00   INFO: remove expired backup 20161010-210823F_20161010-210831I
P00   INFO: remove expired backup 20161010-210823F_20161010-210827D</pre></div></div></div></div><div class="section2"><a id="retention/archive"></a><div class="section2-title">Archive Retention</div><div class="section-body"><div class="section-body-text">Although <span class="backrest">pgBackRest</span> automatically removes archived WAL segments when expiring backups (the default expires WAL for full backups based on the <span class="br-option">retention-full</span> option), it may be useful to expire archive more aggressively to save disk space. Note that full backups are treated as differential backups for the purpose of differential archive retention.</div><div class="section-body-text">Expiring archive will never remove WAL segments that are required to make a backup consistent. However, since Point-in-Time-Recovery (PITR) only works on a continuous WAL stream, care should be taken when aggressively expiring archive outside of the normal backup expiration process.</div><div class="config"><div class="config-title"><span class="host">db-master</span>:<span class="file">/etc/pgbackrest.conf</span> <b>&#x21d2;</b> Configure <span class="br-option">retention-diff</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
db-path=/var/lib/postgresql/9.4/demo<br/>
<br/>
[global]<br/>
repo-path=/var/lib/pgbackrest<br/>
retention-diff=2<br/>
retention-full=2<br/>
start-fast=y<br/>
stop-auto=y</div></div></div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Perform differential backup</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=diff \
       --log-level-console=info backup</pre><pre class="execute-body-output">       [filtered 9 lines of output]
P00   INFO: execute exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 000000020000000000000012, lsn = 0/120000F0</pre><pre class="execute-body-output-highlight">P00   INFO: new backup label = 20161010-210823F_20161010-210840D</pre><pre class="execute-body-output">P00   INFO: backup stop
P00   INFO: expire start 1.09: --log-level-console=info --log-level-stderr=off --repo-path=/var/lib/pgbackrest --retention-archive=2 --retention-diff=2 --retention-full=2 --stanza=demo</pre></div></div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Expire archive</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --log-level-console=detail \
       --retention-archive-type=diff --retention-archive=1 expire</pre><pre class="execute-body-output">P00   INFO: expire start 1.09: --log-level-console=detail --log-level-stderr=off --repo-path=/var/lib/pgbackrest --retention-archive=1 --retention-archive-type=diff --retention-diff=2 --retention-full=2 --stanza=demo
P00 DETAIL: archive retention on backup 20161010-210816F, start = 00000002000000000000000A, stop = 00000002000000000000000A
P00 DETAIL: archive retention on backup 20161010-210823F, start = 00000002000000000000000B, stop = 00000002000000000000000B</pre><pre class="execute-body-output-highlight">P00 DETAIL: archive retention on backup 20161010-210823F_20161010-210835D, start = 00000002000000000000000E, stop = 00000002000000000000000E</pre><pre class="execute-body-output">P00 DETAIL: archive retention on backup 20161010-210823F_20161010-210840D, start = 000000020000000000000012</pre><pre class="execute-body-output-highlight">P00 DETAIL: remove archive: start = 00000002000000000000000C, stop = 00000002000000000000000D
P00 DETAIL: remove archive: start = 00000002000000000000000F, stop = 000000020000000000000011</pre><pre class="execute-body-output">P00   INFO: expire stop</pre></div></div><div class="section-body-text">The <span class="id">20161010-210823F_20161010-210835D</span> differential backup has archived WAL segments that must be retained to make the older backups consistent even though they cannot be played any further forward with PITR. WAL segments generated after <span class="id">20161010-210823F_20161010-210835D</span> but before <span class="id">20161010-210823F_20161010-210840D</span> are removed. WAL segments generated after the new backup <span class="id">20161010-210823F_20161010-210840D</span> remain and can be used for PITR.</div><div class="section-body-text">Since full backups are considered differential backups for the purpose of differential archive retention, if a full backup is now performed with the same settings, only the archive for that full backup is retained for PITR.</div></div></div></div></div><div class="section1"><a id="restore"></a><div class="section1-title">Restore</div><div class="section-body"><div class="section-body-text">The Restore section introduces additional <span class="cmd">restore</span> command features.</div><div class="section2"><a id="restore/option-delta"></a><div class="section2-title">Delta Option</div><div class="section-body"><div class="section-body-text"><a href="#quickstart/perform-restore">Restore a Backup</a> in <a href="#quickstart">Quick Start</a> required the database cluster directory to be cleaned before the <span class="cmd">restore</span> could be performed. The <span class="br-option">delta</span> option allows <span class="backrest">pgBackRest</span> to automatically determine which files in the database cluster directory can be preserved and which ones need to be restored from the backup &mdash; it also <i>removes</i> files not present in the backup manifest so it will dispose of divergent changes. This is accomplished by calculating a <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> cryptographic hash for each file in the database cluster directory. If the <span class="id">SHA-1</span> hash does not match the hash stored in the backup then that file will be restored. This operation is very efficient when combined with the <span class="br-option">process-max</span> option. Since the <span class="postgres">PostgreSQL</span> server is shut down during the restore, a larger number of processes can be used than might be desirable during a backup when the <span class="postgres">PostgreSQL</span> server is running.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Stop the demo cluster, perform delta restore</div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo stop</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta \
       --log-level-console=detail restore</pre><pre class="execute-body-output">       [filtered 693 lines of output]
P01 DETAIL: restore file /var/lib/postgresql/9.4/demo/base/12134/PG_VERSION - exists and matches backup (4B, 99%) checksum 8dbabb96e032b8d9f1993c0e4b9141e71ade01a1
P01 DETAIL: restore file /var/lib/postgresql/9.4/demo/base/1/PG_VERSION - exists and matches backup (4B, 99%) checksum 8dbabb96e032b8d9f1993c0e4b9141e71ade01a1</pre><pre class="execute-body-output-highlight">P01 DETAIL: restore file /var/lib/postgresql/9.4/demo/PG_VERSION - exists and matches backup (4B, 99%) checksum 8dbabb96e032b8d9f1993c0e4b9141e71ade01a1</pre><pre class="execute-body-output">P01 DETAIL: restore file /var/lib/postgresql/9.4/demo/global/12086 - exists and is zero size (0B, 99%)
P01 DETAIL: restore file /var/lib/postgresql/9.4/demo/global/12038 - exists and is zero size (0B, 99%)
       [filtered 84 lines of output]
P01 DETAIL: restore file /var/lib/postgresql/9.4/demo/base/1/11885 - exists and is zero size (0B, 99%)
P00   INFO: wrote /var/lib/postgresql/9.4/demo/recovery.conf</pre><pre class="execute-body-output-highlight">P00   INFO: restore global/pg_control (copied last to ensure aborted restores cannot be started)</pre><pre class="execute-body-output">P00   INFO: restore file /var/lib/postgresql/9.4/demo/global/pg_control (8KB, 100%) checksum 37890ec3622494e3a026f77d4a5a0df7495097c2
P00   INFO: restore stop</pre></div></div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Restart <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo start</pre></div></div></div></div><div class="section2"><a id="restore/option-db-include"></a><div class="section2-title">Restore Selected Databases</div><div class="section-body"><div class="section-body-text">There may be cases where it is desirable to selectively restore specific databases from a cluster backup. This could be done for performance reasons or to move selected databases to a machine that does not have enough space to restore the entire cluster backup.</div><div class="section-body-text">To demonstrate this feature two databases are created: test1 and test2. A fresh backup is run so <span class="backrest">pgBackRest</span> is aware of the new databases.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Create two test databases and perform a backup</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "create database test1;"</pre><pre class="execute-body-output">CREATE DATABASE</pre><pre class="execute-body-cmd">sudo -u postgres psql -c "create database test2;"</pre><pre class="execute-body-output">CREATE DATABASE</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=incr backup</pre></div></div><div class="section-body-text">Each test database will be seeded with tables and data to demonstrate that recovery works with selective restore.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Create a test table in each database</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "create table test1_table (id int); \
       insert into test1_table (id) values (1);" test1</pre><pre class="execute-body-output">INSERT 0 1</pre><pre class="execute-body-cmd">sudo -u postgres psql -c "create table test2_table (id int); \
       insert into test2_table (id) values (2);" test2</pre><pre class="execute-body-output">INSERT 0 1</pre></div></div><div class="section-body-text">One of the main reasons to use selective restore is to save space. The size of the test1 database is shown here so it can be compared with the disk utilization after a selective restore.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Show space used by test1 database</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres du -sh /var/lib/postgresql/9.4/demo/base/16384</pre><pre class="execute-body-output">6.4M	/var/lib/postgresql/9.4/demo/base/16384</pre></div></div><div class="section-body-text">Stop the cluster and restore only the test2 database. Built-in databases (<span class="id">template0</span>, <span class="id">template1</span>, and <span class="id">postgres</span>) are always restored.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Restore from last backup including only the test2 database</div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo stop</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta \
       --db-include=test2 restore</pre><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo start</pre></div></div><div class="section-body-text">Once recovery is complete the test2 database will contain all previously created tables and data.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Demonstrate that the test2 database was recovered</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "select * from test2_table;" test2</pre><pre class="execute-body-output"> id 
----
  2
(1 row)</pre></div></div><div class="section-body-text">The test1 database, despite successful recovery, is not accessible. This is because the entire database was restored as sparse, zeroed files. <span class="postgres">PostgreSQL</span> can successfully apply WAL on the zeroed files but the database as a whole will not be valid because key files contain no data. This is purposeful to prevent the database from being accidentally used when it might contain partial data that was applied during WAL replay.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Attempting to connect to the test1 database will produce an error</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "select * from test1_table;" test1</pre><pre class="execute-body-output-highlight-error">psql: FATAL:  relation mapping file "base/16384/pg_filenode.map" contains invalid data</pre></div></div><div class="section-body-text">Since the test1 database is restored with sparse, zeroed files it will only require as much space as the amount of WAL that is written during recovery. While the amount of WAL generated during a backup and applied during recovery can be significant it will generally be a small fraction of the total database size, especially for large databases where this feature is most likely to be useful.</div><div class="section-body-text">It is clear that the test1 database uses far less disk space during the selective restore than it would have if the entire database had been restored.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Show space used by test1 database after recovery</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres du -sh /var/lib/postgresql/9.4/demo/base/16384</pre><pre class="execute-body-output">152K	/var/lib/postgresql/9.4/demo/base/16384</pre></div></div><div class="section-body-text">At this point the only action that can be taken on the invalid test1 database is <span class="id">drop database</span>. <span class="backrest">pgBackRest</span> does not automatically drop the database since this cannot be done until recovery is complete and the cluster is accessible.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Drop the test1 database</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "drop database test1;"</pre><pre class="execute-body-output">DROP DATABASE</pre></div></div><div class="section-body-text">Now that the invalid test1 database has been dropped only the test2 and built-in databases remain.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> List remaining databases</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "select oid, datname from pg_database order by oid;"</pre><pre class="execute-body-output">  oid  |  datname  
-------+-----------
     1 | template1
 12134 | template0
 12139 | postgres</pre><pre class="execute-body-output-highlight"> 16385 | test2</pre><pre class="execute-body-output">(4 rows)</pre></div></div></div></div></div></div><div class="section1"><a id="pitr"></a><div class="section1-title">Point-in-Time Recovery</div><div class="section-body"><div class="section-body-text"><a href="#quickstart/perform-restore">Restore a Backup</a> in <a href="#quickstart">Quick Start</a> performed default recovery, which is to play all the way to the end of the WAL stream. In the case of a hardware failure this is usually the best choice but for data corruption scenarios (whether machine or human in origin) Point-in-Time Recovery (PITR) is often more appropriate.</div><div class="section-body-text">Point-in-Time Recovery (PITR) allows the WAL to be played from the last backup to a specified time, transaction id, or recovery point. For common recovery scenarios time-based recovery is arguably the most useful. A typical recovery scenario is to restore a table that was accidentally dropped or data that was accidentally deleted. Recovering a dropped table is more dramatic so that's the example given here but deleted data would be recovered in exactly the same way.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Backup the demo cluster and create a table with very important data</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=diff backup</pre><pre class="execute-body-cmd">sudo -u postgres psql -c "begin; \
       create table important_table (message text); \
       insert into important_table values ('Important Data'); \
       commit; \
       select * from important_table;"</pre><pre class="execute-body-output">    message     
----------------</pre><pre class="execute-body-output-highlight"> Important Data</pre><pre class="execute-body-output">(1 row)</pre></div></div><div class="section-body-text">It is important to represent the time as reckoned by <span class="postgres">PostgreSQL</span> and to include timezone offsets. This reduces the possibility of unintended timezone conversions and an unexpected recovery result.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Get the time from <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -Atc "select current_timestamp"</pre><pre class="execute-body-output">2016-10-10 21:09:10.911238+00</pre></div></div><div class="section-body-text">Now that the time has been recorded the table is dropped. In practice finding the exact time that the table was dropped is a lot harder than in this example. It may not be possible to find the exact time, but some forensic work should be able to get you close.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Drop the important table</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "begin; \
       drop table important_table; \
       commit; \
       select * from important_table;"</pre><pre class="execute-body-output-highlight-error">ERROR:  relation "important_table" does not exist</pre><pre class="execute-body-output">LINE 1: ...le important_table;     commit;     select * from important_...
                                                             ^</pre></div></div><div class="section-body-text">Now the restore can be performed with time-based recovery to bring back the missing table.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Stop <span class="postgres">PostgreSQL</span>, restore the demo cluster to <span class="id">2016-10-10 21:09:10.911238+00</span>, and display <span class="file">recovery.conf</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo stop</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta \
       --type=time "--target=2016-10-10 21:09:10.911238+00" restore</pre><pre class="execute-body-cmd">sudo -u postgres cat /var/lib/postgresql/9.4/demo/recovery.conf</pre><pre class="execute-body-output">restore_command = '/usr/bin/pgbackrest --stanza=demo archive-get %f "%p"'</pre><pre class="execute-body-output-highlight">recovery_target_time = '2016-10-10 21:09:10.911238+00'</pre></div></div><div class="section-body-text">The <span class="file">recovery.conf</span> file has been automatically generated by <span class="backrest">pgBackRest</span> so <span class="postgres">PostgreSQL</span> can be started immediately. Once <span class="postgres">PostgreSQL</span> has finished recovery the table will exist again and can be queried.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Start <span class="postgres">PostgreSQL</span> and check that the important table exists</div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo start</pre><pre class="execute-body-cmd">sudo -u postgres psql -c "select * from important_table"</pre><pre class="execute-body-output">    message     
----------------</pre><pre class="execute-body-output-highlight"> Important Data</pre><pre class="execute-body-output">(1 row)</pre></div></div><div class="section-body-text">The <span class="postgres">PostgreSQL</span> log also contains valuable information. It will indicate the time and transaction where the recovery stopped and also give the time of the last transaction to be applied.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Examine the <span class="postgres">PostgreSQL</span> log output</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat /var/log/postgresql/postgresql-9.4-demo.log</pre><pre class="execute-body-output">LOG:  database system was interrupted; last known up at 2016-10-10 21:09:07 UTC
LOG:  creating missing WAL directory "pg_xlog/archive_status"</pre><pre class="execute-body-output-highlight">LOG:  starting point-in-time recovery to 2016-10-10 21:09:10.911238+00</pre><pre class="execute-body-output">LOG:  restored log file "00000004.history" from archive
LOG:  incomplete startup packet
       [filtered 2 lines of output]
LOG:  consistent recovery state reached at 0/170000F0
LOG:  restored log file "000000040000000000000018" from archive</pre><pre class="execute-body-output-highlight">LOG:  recovery stopping before commit of transaction 686, time 2016-10-10 21:09:11.072776+00</pre><pre class="execute-body-output">LOG:  redo done at 0/180157F0</pre><pre class="execute-body-output-highlight">LOG:  last completed transaction was at log time 2016-10-10 21:09:10.767899+00</pre><pre class="execute-body-output">FATAL:  the database system is starting up
LOG:  selected new timeline ID: 5
       [filtered 6 lines of output]</pre></div></div><div class="section-body-text">This example was rigged to give the correct result. If a backup after the required time is chosen then <span class="postgres">PostgreSQL</span> will not be able to recover the lost table. <span class="postgres">PostgreSQL</span> can only play forward, not backward. To demonstrate this the important table must be dropped (again).</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Drop the important table (again)</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "begin; \
       drop table important_table; \
       commit; \
       select * from important_table;"</pre><pre class="execute-body-output-highlight-error">ERROR:  relation "important_table" does not exist</pre><pre class="execute-body-output">LINE 1: ...le important_table;     commit;     select * from important_...
                                                             ^</pre></div></div><div class="section-body-text">Now take a new backup and attempt recovery from the new backup.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Perform a backup then attempt recovery from that backup</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=incr backup</pre><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo stop</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta \
       --type=time "--target=2016-10-10 21:09:10.911238+00" restore</pre><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo start</pre><pre class="execute-body-cmd">sudo -u postgres psql -c "select * from important_table"</pre><pre class="execute-body-output-highlight-error">ERROR:  relation "important_table" does not exist</pre><pre class="execute-body-output">LINE 1: select * from important_table
                      ^</pre></div></div><div class="section-body-text">Looking at the log output it's not obvious that recovery failed to restore the table. The key is to look for the presence of the <q>recovery stopping before...</q> and <q>last completed transaction...</q> log messages. If they are not present then the recovery to the specified point-in-time was not successful.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Examine the <span class="postgres">PostgreSQL</span> log output to discover the recovery was not successful</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat /var/log/postgresql/postgresql-9.4-demo.log</pre><pre class="execute-body-output">LOG:  database system was interrupted; last known up at 2016-10-10 21:09:20 UTC
LOG:  creating missing WAL directory "pg_xlog/archive_status"</pre><pre class="execute-body-output-highlight">LOG:  starting point-in-time recovery to 2016-10-10 21:09:10.911238+00</pre><pre class="execute-body-output">LOG:  restored log file "00000005.history" from archive
LOG:  incomplete startup packet
LOG:  restored log file "000000050000000000000019" from archive
LOG:  redo starts at 0/19000028</pre><pre class="execute-body-output-highlight">LOG:  consistent recovery state reached at 0/190000F0</pre><pre class="execute-body-output">LOG:  redo done at 0/190000F0
FATAL:  the database system is starting up
       [filtered 11 lines of output]</pre></div></div><div class="section-body-text">Using an earlier backup will allow <span class="postgres">PostgreSQL</span> to play forward to the correct time. The <span class="cmd">info</span> command can be used to find the next to last backup.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Get backup info for the demo cluster</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest info</pre><pre class="execute-body-output">stanza: demo
    status: ok

    full backup: 20161010-210816F
        start / stop timestamp: 2016-10-10 21:08:10 / 2016-10-10 21:08:16
        database size: 19.3MB, backup size: 19.3MB
        repository size: 2.2MB, repository backup size: 2.2MB

    full backup: 20161010-210823F
        start / stop timestamp: 2016-10-10 21:08:17 / 2016-10-10 21:08:23
        database size: 19.3MB, backup size: 19.3MB
        repository size: 2.2MB, repository backup size: 2.2MB

    diff backup: 20161010-210823F_20161010-210840D
        start / stop timestamp: 2016-10-10 21:08:36 / 2016-10-10 21:08:40
        database size: 19.3MB, backup size: 8.2KB
        repository size: 2.2MB, repository backup size: 347B
        backup reference list: 20161010-210823F

    incr backup: 20161010-210823F_20161010-210855I
        start / stop timestamp: 2016-10-10 21:08:49 / 2016-10-10 21:08:55
        database size: 31.8MB, backup size: 12.7MB
        repository size: 3.7MB, repository backup size: 1.5MB
        backup reference list: 20161010-210823F
</pre><pre class="execute-body-output-highlight">    diff backup: 20161010-210823F_20161010-210910D</pre><pre class="execute-body-output">        start / stop timestamp: 2016-10-10 21:09:06 / 2016-10-10 21:09:10
        database size: 25.7MB, backup size: 6.5MB
        repository size: 3MB, repository backup size: 788.6KB
        backup reference list: 20161010-210823F

    incr backup: 20161010-210823F_20161010-210922I
        start / stop timestamp: 2016-10-10 21:09:19 / 2016-10-10 21:09:22
        database size: 25.6MB, backup size: 1.9MB
        repository size: 2.9MB, repository backup size: 214.3KB</pre><pre class="execute-body-output-highlight">        backup reference list: 20161010-210823F, 20161010-210823F_20161010-210910D</pre></div></div><div class="section-body-text">The default behavior for restore is to use the last backup but an earlier backup can be specified with the <span class="br-option">--set</span> option.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Stop <span class="postgres">PostgreSQL</span>, restore from the selected backup, and start <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo stop</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta \
       --type=time "--target=2016-10-10 21:09:10.911238+00" \
       --set=20161010-210823F_20161010-210910D restore</pre><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo start</pre><pre class="execute-body-cmd">sudo -u postgres psql -c "select * from important_table"</pre><pre class="execute-body-output">    message     
----------------</pre><pre class="execute-body-output-highlight"> Important Data</pre><pre class="execute-body-output">(1 row)</pre></div></div><div class="section-body-text">Now the the log output will contain the expected <q>recovery stopping before...</q> and <q>last completed transaction...</q> messages showing that the recovery was successful.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Examine the <span class="postgres">PostgreSQL</span> log output for log messages indicating success</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat /var/log/postgresql/postgresql-9.4-demo.log</pre><pre class="execute-body-output">LOG:  database system was interrupted; last known up at 2016-10-10 21:09:07 UTC
LOG:  creating missing WAL directory "pg_xlog/archive_status"</pre><pre class="execute-body-output-highlight">LOG:  starting point-in-time recovery to 2016-10-10 21:09:10.911238+00</pre><pre class="execute-body-output">LOG:  restored log file "00000004.history" from archive
LOG:  incomplete startup packet
       [filtered 2 lines of output]
LOG:  consistent recovery state reached at 0/170000F0
LOG:  restored log file "000000040000000000000018" from archive</pre><pre class="execute-body-output-highlight">LOG:  recovery stopping before commit of transaction 686, time 2016-10-10 21:09:11.072776+00</pre><pre class="execute-body-output">LOG:  redo done at 0/180157F0</pre><pre class="execute-body-output-highlight">LOG:  last completed transaction was at log time 2016-10-10 21:09:10.767899+00</pre><pre class="execute-body-output">FATAL:  the database system is starting up
LOG:  restored log file "00000005.history" from archive
       [filtered 9 lines of output]</pre></div></div></div></div><div class="section1"><a id="backup-host"></a><div class="section1-title">Dedicated Backup Host</div><div class="section-body"><div class="section-body-text">The configuration described in <a href="#quickstart">Quickstart</a> is suitable for simple installations but for enterprise configurations it is more typical to have a dedicated <span class="host">backup</span> host. This separates the backups and WAL archive from the database server so <span class="host">database</span> host failures have less impact. It is still a good idea to employ traditional backup software to backup the <span class="host">backup</span> host.</div><div class="section2"><a id="backup-host/install-config"></a><div class="section2-title">Installation and Configuration</div><div class="section-body"><div class="section-body-text">For this example a new host named <span class="host">backup</span> has been created to store the cluster backups. Follow the instructions in <a href="#installation">Installation</a> to install <span class="backrest">pgBackRest</span> and <a href="#quickstart/create-repository">Create the Repository</a> to create the <span class="backrest">pgBackRest</span> repository. The <span class="host">backup</span> host must also be configured with the <span class="host">db-master</span> host/user and database path. The master database will be configured as <span class="id">db1</span> to allow a standby to be added later.</div><div class="config"><div class="config-title"><span class="host">backup</span>:<span class="file">/etc/pgbackrest.conf</span> <b>&#x21d2;</b> Configure <span class="br-option">db1-host</span>/<span class="br-option">db1-user</span> and <span class="br-option">db1-path</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
db1-host=db-master<br/>
db1-path=/var/lib/postgresql/9.4/demo<br/>
db1-user=postgres<br/>
<br/>
[global]<br/>
repo-path=/var/lib/pgbackrest<br/>
start-fast=y</div></div></div><div class="section-body-text">The database host must be configured with the backup host/user. The default for the <span class="br-option">backup-user</span> option is <span class="id">backrest</span>. If the <span class="id">postgres</span> user does restores on the backup host it is best not to also allow the <span class="id">postgres</span> user to perform backups. However, the <span class="id">postgres</span> user can read the repository directly if it is in the same group as the <span class="id">backrest</span> user.</div><div class="config"><div class="config-title"><span class="host">db-master</span>:<span class="file">/etc/pgbackrest.conf</span> <b>&#x21d2;</b> Configure <span class="br-option">backup-host</span>/<span class="br-option">backup-user</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
db-path=/var/lib/postgresql/9.4/demo<br/>
<br/>
[global]<br/>
backup-host=backup<br/>
backup-user=backrest<br/>
repo-path=/var/lib/pgbackrest</div></div></div><div class="section-body-text">The repository directory will also be removed from the database host. It will not be used anymore so leaving it around may be confusing later on.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Remove repository now that it will be located on the database server</div><div class="execute-body"><pre class="execute-body-cmd">sudo find /var/lib/pgbackrest -delete</pre></div></div><div class="section-body-text">Commands are run the same as on a single host configuration except that the <span class="cmd">backup</span> and <span class="cmd">expire</span> command are run from the <span class="host">backup</span> host and all other commands are run from the <span class="host">database</span> host.</div><div class="section-body-text">Check that the configuration is correct on both the <span class="host">database</span> and <span class="host">backup</span> hosts. More information about the <span class="cmd">check</span> command can be found in <a href="#quickstart/check-configuration">Check the Configuration</a>.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Check the configuration</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo check</pre></div></div><div class="execute"><div class="execute-title"><span class="host">backup</span> <b>&#x21d2;</b> Check the configuration</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u backrest pgbackrest --stanza=demo check</pre></div></div></div></div><div class="section2"><a id="backup-host/perform-backup"></a><div class="section2-title">Perform a Backup</div><div class="section-body"><div class="section-body-text">To perform a backup of the <span class="postgres">PostgreSQL</span> cluster run <span class="backrest">pgBackRest</span> with the <span class="cmd">backup</span> command on the <span class="host">backup</span> host.</div><div class="execute"><div class="execute-title"><span class="host">backup</span> <b>&#x21d2;</b> Backup the demo cluster</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u backrest pgbackrest --stanza=demo backup</pre><pre class="execute-body-output">P00   WARN: option retention-full is not set, the repository may run out of space
       HINT: to retain full backups indefinitely (without warning), set option 'retention-full' to the maximum.
P00   WARN: no prior backup exists, incr backup has been changed to full</pre></div></div><div class="section-body-text">Since a new repository was created on the <span class="host">backup</span> host the warning about the incremental backup changing to a full backup was emitted.</div></div></div><div class="section2"><a id="backup-host/perform-restore"></a><div class="section2-title">Restore a Backup</div><div class="section-body"><div class="section-body-text">To perform a restore of the <span class="postgres">PostgreSQL</span> cluster run <span class="backrest">pgBackRest</span> with the <span class="cmd">restore</span> command on the <span class="host">database</span> host.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Stop the demo cluster, restore, and restart <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo stop</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta restore</pre><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo start</pre></div></div><div class="section-body-text">A new backup must be performed due to the timeline switch.</div><div class="execute"><div class="execute-title"><span class="host">backup</span> <b>&#x21d2;</b> Backup the demo cluster</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u backrest pgbackrest --stanza=demo backup</pre></div></div></div></div><div class="section2"><a id="backup-host/async-archiving"></a><div class="section2-title">Asynchronous Archiving</div><div class="section-body"><div class="section-body-text">The <span class="br-option">archive-async</span> option offloads WAL archiving to a separate process to improve throughput. WAL segments are temporarily stored in a local queue on the database server, specified by the <span class="br-option">spool-path</span> option, before being transferred to the repository on the backup server.</div><div class="section-body-text">The spool directory is created to hold the WAL segments while they are waiting to be (optionally) compressed and transferred.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Create the spool directory</div><div class="execute-body"><pre class="execute-body-cmd">sudo mkdir -m 750 /var/spool/pgbackrest</pre><pre class="execute-body-cmd">sudo chown postgres:postgres /var/spool/pgbackrest</pre></div></div><div class="section-body-text">The spool path must be configured and asynchronous archiving enabled.</div><div class="config"><div class="config-title"><span class="host">db-master</span>:<span class="file">/etc/pgbackrest.conf</span> <b>&#x21d2;</b> Configure the spool path and asynchronous archiving</div><div class="config-body"><div class="config-body-output">[demo]<br/>
db-path=/var/lib/postgresql/9.4/demo<br/>
<br/>
[global]<br/>
archive-async=y<br/>
backup-host=backup<br/>
backup-user=backrest<br/>
repo-path=/var/lib/pgbackrest<br/>
spool-path=/var/spool/pgbackrest</div></div></div><div class="section-body-text">The <span class="cmd">check</span> command ensures that asynchronous archiving is working.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Check asynchronous archiving</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --log-level-console=info check</pre><pre class="execute-body-output">P00   INFO: check start 1.09: --backup-host=backup --backup-user=backrest --db-path=/var/lib/postgresql/9.4/demo --log-level-console=info --log-level-stderr=off --repo-path=/var/lib/pgbackrest --stanza=demo
P00   INFO: switch xlog 00000008000000000000001D</pre><pre class="execute-body-output-highlight">P00   INFO: WAL segment 00000008000000000000001D successfully stored in the archive at '/var/lib/pgbackrest/archive/demo/9.4-1/0000000800000000/00000008000000000000001D-91c05b117e97531d3a8e42739901dfa8a0efcd17.gz'</pre><pre class="execute-body-output">P00   INFO: check stop</pre></div></div></div></div></div></div><div class="section1"><a id="start-stop"></a><div class="section1-title">Starting and Stopping</div><div class="section-body"><div class="section-body-text">Sometimes it is useful to prevent <span class="backrest">pgBackRest</span> from running on a system. For example, when failing over from a master to a standby it's best to prevent <span class="backrest">pgBackRest</span> from running on the old master in case <span class="postgres">PostgreSQL</span> gets restarted or can't be completely killed. This will also prevent <span class="backrest">pgBackRest</span> from running on <span class="id">cron</span>.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Stop the <span class="backrest">pgBackRest</span> services</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest stop</pre></div></div><div class="section-body-text">New <span class="backrest">pgBackRest</span> processes will no longer run.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Attempt a backup</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo backup</pre><pre class="execute-body-output">P00   WARN: option retention-full is not set, the repository may run out of space
       HINT: to retain full backups indefinitely (without warning), set option 'retention-full' to the maximum.</pre><pre class="execute-body-output-highlight-error">P00  ERROR: [137]: stop file exists for all stanzas</pre></div></div><div class="section-body-text">Specify the <span class="br-option">--force</span> option to terminate any <span class="backrest">pgBackRest</span> process that are currently running. If <span class="backrest">pgBackRest</span> is already stopped then stopping again will generate a warning.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Stop the <span class="backrest">pgBackRest</span> services again</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest stop</pre><pre class="execute-body-output">P00   WARN: stop file already exists for all stanzas</pre></div></div><div class="section-body-text">Start <span class="backrest">pgBackRest</span> processes again with the <span class="cmd">start</span> command.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Start the <span class="backrest">pgBackRest</span> services</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest start</pre></div></div><div class="section-body-text">It is also possible to stop <span class="backrest">pgBackRest</span> for a single stanza.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Stop <span class="backrest">pgBackRest</span> services for the <span class="id">demo</span> stanza</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo stop</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo backup</pre><pre class="execute-body-output">P00   WARN: option retention-full is not set, the repository may run out of space
       HINT: to retain full backups indefinitely (without warning), set option 'retention-full' to the maximum.</pre><pre class="execute-body-output-highlight-error">P00  ERROR: [137]: stop file exists for stanza demo</pre></div></div><div class="section-body-text">The stanza must also be specified when starting the <span class="backrest">pgBackRest</span> processes for a single stanza.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Start the <span class="backrest">pgBackRest</span> services for the <span class="id">demo</span> stanza</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo start</pre></div></div></div></div><div class="section1"><a id="replication"></a><div class="section1-title">Replication</div><div class="section-body"><div class="section-body-text">Replication allows multiple copies of a <span class="postgres">PostgreSQL</span> cluster (called standbys) to be created from a single master. The standbys are useful for balancing reads and to provide redundancy in case the master host fails.</div><div class="section2"><a id="replication/hot-standby"></a><div class="section2-title">Hot Standby</div><div class="section-body"><div class="section-body-text">A hot standby performs replication using the WAL archive and allows read-only queries.</div><div class="section-body-text">A new host named <span class="host">db-standby</span> will be created to run the standby. Follow the instructions in <a href="#installation">Installation</a> to install <span class="backrest">pgBackRest</span>, <a href="#quickstart/setup-demo-cluster">Setup Demo Cluster</a> to setup the demo cluster, and <a href="#quickstart/create-repository">Create the Repository</a> to create the <span class="backrest">pgBackRest</span> repository on the <span class="host">db-standby</span> host.</div><div class="section-body-text"><span class="backrest">pgBackRest</span> configuration is very similar to <span class="host">db-master</span> except that the <span class="pg-option">standby_mode</span> setting will be enabled to keep the cluster in recovery mode when the end of the WAL stream has been reached.</div><div class="config"><div class="config-title"><span class="host">db-standby</span>:<span class="file">/etc/pgbackrest.conf</span> <b>&#x21d2;</b> Configure <span class="backrest">pgBackRest</span> on the standby</div><div class="config-body"><div class="config-body-output">[demo]<br/>
db-path=/var/lib/postgresql/9.4/demo<br/>
recovery-option=standby_mode=on<br/>
<br/>
[global]<br/>
backup-host=backup<br/>
repo-path=/var/lib/pgbackrest</div></div></div><div class="section-body-text">Now the standby can be created with the <span class="cmd">restore</span> command.</div><div class="execute"><div class="execute-title"><span class="host">db-standby</span> <b>&#x21d2;</b> Restore the demo standby cluster</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta restore</pre><pre class="execute-body-cmd">sudo -u postgres cat /var/lib/postgresql/9.4/demo/recovery.conf</pre><pre class="execute-body-output">standby_mode = 'on'
restore_command = '/usr/bin/pgbackrest --stanza=demo archive-get %f "%p"'</pre></div></div><div class="section-body-text">Note that the <span class="pg-setting">standby_mode</span> setting has been written into the <span class="file">recovery.conf</span> file. Configuring recovery settings in <span class="backrest">pgBackRest</span> means that the <span class="file">recovery.conf</span> file does not need to be stored elsewhere since it will be properly recreated with each restore. The <span class="br-setting">--type=preserve</span> option can be used with the <span class="cmd">restore</span> to leave the existing <span class="file">recovery.conf</span> file in place if that behavior is preferred.</div><div class="section-body-text">The <span class="pg-setting">hot_standby</span> setting must be enabled before starting <span class="postgres">PostgreSQL</span> to allow read-only connections on <span class="host">db-standby</span>. Otherwise, connection attempts will be refused.</div><div class="config"><div class="config-title"><span class="host">db-standby</span>:<span class="file">/etc/postgresql/9.4/demo/postgresql.conf</span> <b>&#x21d2;</b> Enable <span class="pg-option">hot_standby</span></div><div class="config-body"><div class="config-body-output">hot_standby = on<br/>
log_filename = 'postgresql.log'<br/>
log_line_prefix = ''</div></div></div><div class="execute"><div class="execute-title"><span class="host">db-standby</span> <b>&#x21d2;</b> Start <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo start</pre></div></div><div class="section-body-text">The <span class="postgres">PostgreSQL</span> log gives valuable information about the recovery. Note especially that the cluster has entered standby mode and is ready to accept read-only connections.</div><div class="execute"><div class="execute-title"><span class="host">db-standby</span> <b>&#x21d2;</b> Examine the <span class="postgres">PostgreSQL</span> log output for log messages indicating success</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat /var/log/postgresql/postgresql-9.4-demo.log</pre><pre class="execute-body-output">LOG:  database system was interrupted; last known up at 2016-10-10 21:10:07 UTC
LOG:  creating missing WAL directory "pg_xlog/archive_status"</pre><pre class="execute-body-output-highlight">LOG:  entering standby mode</pre><pre class="execute-body-output">LOG:  restored log file "00000008.history" from archive
LOG:  incomplete startup packet
LOG:  restored log file "00000008000000000000001C" from archive
LOG:  redo starts at 0/1C000028
LOG:  consistent recovery state reached at 0/1C0000F0</pre><pre class="execute-body-output-highlight">LOG:  database system is ready to accept read only connections</pre><pre class="execute-body-output">LOG:  restored log file "00000008000000000000001D" from archive</pre></div></div><div class="section-body-text">An easy way to test that replication is properly configured is to create a table on <span class="host">db-master</span>.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Create a new table on the master</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c " \
       begin; \
       create table replicated_table (message text); \
       insert into replicated_table values ('Important Data'); \
       commit; \
       select * from replicated_table";</pre><pre class="execute-body-output">    message     
----------------</pre><pre class="execute-body-output-highlight"> Important Data</pre><pre class="execute-body-output">(1 row)</pre></div></div><div class="section-body-text">And then query the same table on <span class="host">db-standby</span>.</div><div class="execute"><div class="execute-title"><span class="host">db-standby</span> <b>&#x21d2;</b> Query new table on the standby</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "select * from replicated_table;"</pre><pre class="execute-body-output-highlight-error">ERROR:  relation "replicated_table" does not exist</pre><pre class="execute-body-output">LINE 1: select * from replicated_table;
                      ^</pre></div></div><div class="section-body-text">So, what went wrong? Since <span class="postgres">PostgreSQL</span> is pulling WAL segments from the archive to perform replication, changes won't be seen on the standby until the WAL segment that contains those changes is pushed from <span class="host">db-master</span>.</div><div class="section-body-text">This can be done manually by calling <span class="id">pg_switch_xlog()</span> which pushes the current WAL segment to the archive (a new WAL segment is created to contain further changes).</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Call <span class="id">pg_switch_xlog()</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "select *, current_timestamp from pg_switch_xlog()";</pre><pre class="execute-body-output"> pg_switch_xlog |              now              
----------------+-------------------------------
 0/1E017990     | 2016-10-10 21:10:32.802443+00
(1 row)</pre></div></div><div class="section-body-text">Now after a short delay the table will appear on <span class="host">db-standby</span>.</div><div class="execute"><div class="execute-title"><span class="host">db-standby</span> <b>&#x21d2;</b> Now the new table exists on the standby (may require a few retries)</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c " \
       select *, current_timestamp from replicated_table"</pre><pre class="execute-body-output">    message     |              now              
----------------+-------------------------------</pre><pre class="execute-body-output-highlight"> Important Data | 2016-10-10 21:10:36.423567+00</pre><pre class="execute-body-output">(1 row)</pre></div></div></div></div><div class="section2"><a id="replication/streaming"></a><div class="section2-title">Streaming Replication</div><div class="section-body"><div class="section-body-text">Instead of relying solely on the WAL archive, streaming replication makes a direct connection to the master and applies changes as soon as they are made on the master. This results in much less lag between the master and standby.</div><div class="section-body-text">Streaming replication requires a user with the replication privilege.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Create replication user</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c " \
       create user replicator password 'jw8s0F4' replication";</pre><pre class="execute-body-output">CREATE ROLE</pre></div></div><div class="section-body-text">The <span class="file">pg_hba.conf</span> file must be updated to allow the standby to connect as the replication user. Be sure to replace the IP address below with the actual IP address of your <span class="host">db-master</span>. A reload will be required after modifying the <span class="file">pg_hba.conf</span> file.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Create <span class="file">pg_hba.conf</span> entry for replication user</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres sh -c 'echo \
       "host    replication     replicator      172.17.0.4/32           md5" \
       >> /etc/postgresql/9.4/demo/pg_hba.conf'</pre><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo reload</pre></div></div><div class="section-body-text">The standby needs to know how to contact the master so the <span class="pg-option">primary_conninfo</span> setting will be configured in <span class="backrest">pgBackRest</span>.</div><div class="config"><div class="config-title"><span class="host">db-standby</span>:<span class="file">/etc/pgbackrest.conf</span> <b>&#x21d2;</b> Set <span class="pg-option">primary_conninfo</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
db-path=/var/lib/postgresql/9.4/demo<br/>
recovery-option=standby_mode=on<br/>
recovery-option=primary_conninfo=host=172.17.0.2 port=5432 user=replicator<br/>
<br/>
[global]<br/>
backup-host=backup<br/>
repo-path=/var/lib/pgbackrest</div></div></div><div class="section-body-text">It is possible to configure a password in the <span class="pg-option">primary_conninfo</span> setting but using a <span class="file">.pgpass</span> file is more flexible and secure.</div><div class="execute"><div class="execute-title"><span class="host">db-standby</span> <b>&#x21d2;</b> Configure the replication password in the <span class="file">.pgpass</span> file.</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres sh -c 'echo \
       "172.17.0.2:*:replication:replicator:jw8s0F4" \
       >> /home/postgres/.pgpass'</pre><pre class="execute-body-cmd">sudo -u postgres chmod 600 /home/postgres/.pgpass</pre></div></div><div class="section-body-text">Now the standby can be created with the <span class="cmd">restore</span> command.</div><div class="execute"><div class="execute-title"><span class="host">db-standby</span> <b>&#x21d2;</b> Stop <span class="postgres">PostgreSQL</span> and restore the demo standby cluster</div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo stop</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta restore</pre><pre class="execute-body-cmd">sudo -u postgres cat /var/lib/postgresql/9.4/demo/recovery.conf</pre><pre class="execute-body-output">primary_conninfo = 'host=172.17.0.2 port=5432 user=replicator'
standby_mode = 'on'
restore_command = '/usr/bin/pgbackrest --stanza=demo archive-get %f "%p"'</pre></div></div><div class="execute"><div class="execute-title"><span class="host">db-standby</span> <b>&#x21d2;</b> Start <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo pg_ctlcluster 9.4 demo start</pre></div></div><div class="section-body-text">The <span class="postgres">PostgreSQL</span> log will confirm that streaming replication has started.</div><div class="execute"><div class="execute-title"><span class="host">db-standby</span> <b>&#x21d2;</b> Examine the <span class="postgres">PostgreSQL</span> log output for log messages indicating success</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat /var/log/postgresql/postgresql-9.4-demo.log</pre><pre class="execute-body-output">       [filtered 9 lines of output]
LOG:  restored log file "00000008000000000000001D" from archive
LOG:  restored log file "00000008000000000000001E" from archive</pre><pre class="execute-body-output-highlight">LOG:  started streaming WAL from primary at 0/1F000000 on timeline 8</pre></div></div><div class="section-body-text">Now when a table is created on <span class="host">db-master</span> it will appear on <span class="host">db-standby</span> quickly and without the need to call <span class="id">pg_switch_xlog()</span>.</div><div class="execute"><div class="execute-title"><span class="host">db-master</span> <b>&#x21d2;</b> Create a new table on the master</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c " \
       begin; \
       create table stream_table (message text); \
       insert into stream_table values ('Important Data'); \
       commit; \
       select *, current_timestamp from stream_table";</pre><pre class="execute-body-output">    message     |              now              
----------------+-------------------------------</pre><pre class="execute-body-output-highlight"> Important Data | 2016-10-10 21:10:44.760232+00</pre><pre class="execute-body-output">(1 row)</pre></div></div><div class="execute"><div class="execute-title"><span class="host">db-standby</span> <b>&#x21d2;</b> Query table on the standby</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c " \
       select *, current_timestamp from stream_table"</pre><pre class="execute-body-output">    message     |              now              
----------------+-------------------------------</pre><pre class="execute-body-output-highlight"> Important Data | 2016-10-10 21:10:44.942433+00</pre><pre class="execute-body-output">(1 row)</pre></div></div></div></div></div></div><div class="section1"><a id="standby-backup"></a><div class="section1-title">Backup from a Standby</div><div class="section-body"><div class="section-body-text"><span class="backrest">pgBackRest</span> can perform backups on a standby instead of the master. Standby backups require the <span class="host">db-standby</span> host to be configured and the <span class="br-option">backup-standby</span> option enabled.</div><div class="config"><div class="config-title"><span class="host">backup</span>:<span class="file">/etc/pgbackrest.conf</span> <b>&#x21d2;</b> Configure <span class="br-option">db2-host</span>/<span class="br-option">db2-user</span> and <span class="br-option">db2-path</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
db1-host=db-master<br/>
db1-path=/var/lib/postgresql/9.4/demo<br/>
db1-user=postgres<br/>
db2-host=db-standby<br/>
db2-path=/var/lib/postgresql/9.4/demo<br/>
db2-user=postgres<br/>
<br/>
[global]<br/>
backup-standby=y<br/>
repo-path=/var/lib/pgbackrest<br/>
start-fast=y</div></div></div><div class="section-body-text">Both the master and standby databases are required to perform the backup, though the vast majority of the files will be copied from the standby to reduce load on the master. The database hosts can be configured in any order. <span class="backrest">pgBackRest</span> will automatically determine which is the master and which is the standby.</div><div class="execute"><div class="execute-title"><span class="host">backup</span> <b>&#x21d2;</b> Backup the demo cluster from <span class="host">db-standby</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u backrest pgbackrest --stanza=demo --log-level-console=detail backup</pre><pre class="execute-body-output">       [filtered 4 lines of output]
P00   INFO: execute exclusive pg_start_backup() with label "pgBackRest backup started at 2016-10-10 21:10:45": backup begins after the requested immediate checkpoint completes
P00   INFO: backup start archive = 000000080000000000000020, lsn = 0/20000028</pre><pre class="execute-body-output-highlight">P00   INFO: wait for replay on the standby to reach 0/20000028
P00   INFO: replay on the standby reached 0/20000100</pre><pre class="execute-body-output">P01   INFO: local process 1 start for host db-1
P02   INFO: local process 2 start for host db-2
P01   INFO: local process 1 stop for db-1</pre><pre class="execute-body-output-highlight">P01   INFO: backup file db-master:/var/lib/postgresql/9.4/demo/backup_label (238B, 0%) checksum 41bc0bfc7279bfdccfbd5b29ff4756835a49913f</pre><pre class="execute-body-output">P02   INFO: backup file db-standby:/var/lib/postgresql/9.4/demo/base/12139/12007 (392KB, 20%) checksum 6d51543c467d204f7c0282c8e81487ad171d4f32
P02   INFO: backup file db-standby:/var/lib/postgresql/9.4/demo/base/12139/11889 (344KB, 38%) checksum 7782684b828ae5470ab57d977e3da931d968e2e7
       [filtered 26 lines of output]
P02   INFO: local process 2 stop for db-2
P02   INFO: backup file db-standby:/var/lib/postgresql/9.4/demo/base/12139/32771 (0B, 99%)</pre><pre class="execute-body-output-highlight">P00   INFO: backup file db-master:/var/lib/postgresql/9.4/demo/global/pg_control (8KB, 100%) checksum f192e38106c3da22c11f9bf9ddebc31836a4f75a</pre><pre class="execute-body-output">P00   INFO: incr backup size = 1.8MB
P00   INFO: execute exclusive pg_stop_backup() and wait for all WAL segments to archive
       [filtered 5 lines of output]</pre></div></div><div class="section-body-text">This incremental backup shows that most of the files are copied from the <span class="host">db-standby</span> host and only a few are copied from the <span class="host">db-master</span> host.</div><div class="section-body-text"><span class="backrest">pgBackRest</span> creates a standby backup that is identical to a backup performed on the master. It does this by starting/stopping the backup on the <span class="host">db-master</span> host, copying only files that are replicated from the <span class="host">db-standby</span> host, the copying the remaining few files from the <span class="host">db-master</span> host. This means that logs and statistics from the master database will be included in the backup.</div></div></div></div><div class="page-footer">Copyright &copy; 2015-2016, The PostgreSQL Global Development Group, <a href="https://github.com/pgbackrest/pgbackrest/blob/master/LICENSE">MIT License</a>.  Updated October 10, 2016</div></body></html>